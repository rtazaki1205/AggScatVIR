import numpy as np
from plots import *
from agginfo import *

import sys
import os.path

import matplotlib
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from matplotlib.ticker import MultipleLocator, FormatStrFormatter


class dustmodel:
    """
    A class to read `dustkapscatmat_XXX.inp` and store the information therein

    Parameters
    ----------
    partype : str
              Dust particle type:
              ``'FA11'``, ``'FA13'``, ``'FA15'``, ``'FA19'``,
              ``'CAHP'``, ``'CAMP'``, ``'CALP'``, ``'grs'``
    size : str
        | Dust particle size
        | **For aggregates**: the number of monomers.
        |   *Example*: ``size='4096'`` if you want an aggregate consisting of 4096 monomers.  
        | **For irregular grains**: the volume-equivalent radius in units of microns
        |   (the dicimal dot should be replaced by the underscore).
        |   *Example*: ``size='1_6000'`` if you want an irregular grain with the volume-eq. radius of 1.6 microns.
        |
        | You can also use ``agginfo.get_sizelist`` to obtain a list of available size values.
    comp : str
              Dust composition. **Available input values**: ``'org'``, ``'amc'``
    amon    : str (optional)
              Monomer radius (necessary if you call aggregate files).
              **Available input values**:
              ``'100nm'``, (``'150nm'``), ``'200nm'``, (``'300nm'``), ``'400nm'``
              *Note*: 150nm and 300nm are only available for fractal aggregates.
    dist : bool (optional)
           With size distribution (default: dist=True).
    chop : str (optional)
           Forward scattering chop (default: chop='nochop'). 
           **Available input values**: ``'nochop'``, ``'chop5'``, ``'chop10'``
    smatBH : bool (optional)
             Output the scattering matrix elements in the 
             Bohren & Huffman definition (default: smatBH=False).
    filename : str (optical)
               A relative path to dustkapscatmat_XXX.inp in case if you want 
               to reload a file generated by this tool.

    Attributes
    ----------
    model : str
            dust model name 
    path  : str
            A relative path to the file
    dist  : bool
            True when the size distribution is on
    aggop : bool
            True when the input particle type is aggregates
    nlam  : int
            Number of wavelength grids
    nang  : int
            Number of scattering angle grids
    lmd   : float[nlam]
            Wavelength (microns)
    scatang : float[nang]
            Scattering angles (degrees)
    kabs,ksca,asym : float[nlam]
            Absorption and scattering opacities (cm^2/g) and the asymmetry parameter.
    cabs,csca : float[nlam]
            Absorption and scattering cross sections (micron^2)
    albedo  : float[nlam]
            Single scattering albedo (=ksca/(kabs+ksca))
    pmax    : float[nlam]
            Maximum degree of linear polariation
    smat11,smat12,smat22,smat33,smat34,smat44: float[nlmd,nang]
            Scattering matrix elements (RADMC-3D's definition when smatBH=False)
    phase: float[nlmd,nang]
            Scattering phase function
    rhomat : float
            Material density (g/cc)
    chopang : float 
            The chop angle for the forward scattering peak (degrees)
    mass    : float
            Mass of a dust particle (Or distribution averaged mass if size distribution is present) (g).
    avmin, avmax  : float (*only when* ``dist=True``)
            Volume-equivalent radii of the minimum and maximum particles in the size distribution
    av     : float (*only when* ``dist=False``)
            Volume-equivalent radius (micron) 
    pow    : float (*only when* ``dist=True``)
            Power-law index of size distribution: n(a)da propto a^{-p}da
    amon   : float (*only when* ``partype!='grs'``)
            Monomer radius (microns)
            Number of monomers of the minimum aggregate in the size distribution
    npmin, npmax  : float (*only when* ``partype!='grs'`` *and* ``dist=True``)
            Number of monomers of the minimum and maximum aggregates in the size distribution (if dist=True)
    acmin, acmax  : float (*only when* ``partype!='grs'`` *and* ``dist=True``)
            Characteristic radius of the minimum and maximum aggregates in the size distribution
    pormin,pormax : float (*only when* ``partype!='grs'`` *and* ``dist=True``)
            Porosity of the minimum and maximum aggregates in the size distribution
    np     : float (*only when* ``partype!='grs'`` *and* ``dist=False``)
            Number of monomers
    ac     : float (*only when* ``partype!='grs'`` *and* ``dist=False``)
            Characteristic radius (micron)
    por    : float (*only when* ``partype!='grs'`` *and* ``dist=False``)
            Porosity of the aggregate
    """

    def __init__(self,partype=None,size=None,comp=None,amon=None,dist=True,chop='nochop',smatBH=False,filename=None):
        """
        Constructs all the necessary attributes for the dustmodel object.
        """

        self.dist=dist

        if filename==None:
            read_default_file=True

            # generate file name
            if chop not in ['nochop', 'chop5', 'chop10']:
                print('error: incorrect chop option')
                print('input value = ',chop)
                print('available options are' ,['nochop', 'chop5', 'chop10'])
                exit()
            
            if chop=='nochop':
                self.chopang=0.0
            elif chop=='chop5':
                self.chopang=5.0
            elif chop=='chop10':
                self.chopang=10.0

            # check partype
            if partype not in ['grs','CALP','CAMP','CAHP','FA19','FA15','FA13','FA11']:
                print('error: incorrect particle type')
                print('input value = ',partype)
                print('available options are ',['grs','CALP','CAMP','CAHP','FA19','FA15','FA13','FA11'])
                exit()

            # if grs, reset monomer radius option
            if partype == 'grs':
                amon=None

            # get a list of particle size
            nl=get_sizelist(partype,amon=amon)
            
            # check consistency between monomer radius and number of monomers
            if size not in nl:
                print('Incorrect particle size')
                print('input particle type =',partype)
                if partype != 'grs':
                    print('input monomer radius =',amon)
                if not nl:
                    print('--> this monomer radius is not available')
                else:
                    print('available size option is ',nl)
                exit()

            # check composition
            if comp not in ['org','amc']:
                print("unknown dust composition")
                print("Set either comp='org' or 'amc'")
                exit()

            # set modelname and filename
            if partype=='grs':
                self.aggop=False
                if dist:
                    filename='../aggscatrt/distave/'
                    if chop=='nochop':
                        modelname=partype+'_rvmax'+size+'um_'+comp
                    elif chop=='chop5':
                        modelname=partype+'_rvmax'+size+'um_'+comp+'_chop5'
                    elif chop=='chop10':
                        modelname=partype+'_rvmax'+size+'um_'+comp+'_chop10'
                else:
                    filename='../aggscatrt/single/'
                    if chop=='nochop':
                        modelname=partype+'_rv'+size+'um_'+comp
                    elif chop=='chop5':
                        modelname=partype+'_rv'+size+'um_'+comp+'_chop5'
                    elif chop=='chop10':
                        modelname=partype+'_rv'+size+'um_'+comp+'_chop10'

            elif partype=='CALP' or partype =='CAMP' or partype=='CAHP' or \
                partype=='FA19' or partype=='FA15' or partype=='FA13' or \
                partype=='FA11':

                self.aggop=True
                if dist:
                    filename='../aggscatrt/distave/'
                    if chop=='nochop':
                        modelname=partype+'_Nmax'+size+'_'+amon+'_'+comp
                    elif chop=='chop5':
                        modelname=partype+'_Nmax'+size+'_'+amon+'_'+comp+'_chop5'
                    elif chop=='chop10':
                        modelname=partype+'_Nmax'+size+'_'+amon+'_'+comp+'_chop10'
                else:
                    filename='../aggscatrt/single/'
                    if chop=='nochop':
                        modelname=partype+'_'+size+'_'+amon+'_'+comp
                    elif chop=='chop5':
                        modelname=partype+'_'+size+'_'+amon+'_'+comp+'_chop5'
                    elif chop=='chop10':
                        modelname=partype+'_'+size+'_'+amon+'_'+comp+'_chop10'
            else:
                print('error: filename generation was not done correctly.')
                print('strange!')
                exit()

            filename=filename+chop+'/dustkapscatmat_'+modelname+'.inp'
        
        else:
            read_default_file=False

            if os.path.isfile(filename)==False:
                print('Error! No such file found :',filename)
                exit()
            else:
                print('...reading ',filename)
                if '.inp' not in filename:
                    print('   Error! The file name does not follow dustkapscatmat_XXX.inp' )
                    print('          Please make sure if this file is given in the RADMC-3D format.')
                    exit()
                if 'dustkapscatmat_' not in filename:
                    print('   Error! The file name does not follow dustkapscatmat_XXX.inp' )
                    print('          Please make sure if this file is given in the RADMC-3D format.')
                    exit()

                with open(filename,'r') as f:
                    dum=f.readline()
                    dum=f.readline()
                    dum=f.readline()
                    modelname=dum.split()[-1]

                self.dist=True
                self.aggop=True
                if 'grs' in modelname:
                    self.aggop=False
                elif 'FA11' in modelname:
                    self.aggop=True
                elif 'FA13' in modelname:
                    self.aggop=True
                elif 'FA15' in modelname:
                    self.aggop=True
                elif 'FA19' in modelname:
                    self.aggop=True
                elif 'CAHP' in modelname:
                    self.aggop=True
                elif 'CAMP' in modelname:
                    self.aggop=True
                elif 'CALP' in modelname:
                    self.aggop=True
                else:
                    print('   Error! this file does not contain the information of aggregate/irregular grain.')
                    print('          Currently this class can only read files generated by AggScatVIR.      ')
                    exit()

        #
        self.model=modelname
        self.path=filename
        
        # start reading dustkapscatmat.inp
        header=''
        with open(filename,'r') as f:
            dum=f.readline()
            while (dum.strip()[0]=='#'):
                if self.aggop:
                    if self.dist:
                        if 'material density' in dum:
                            self.rhomat=float(dum.split()[-1])
                        if 'Monomer radius' in dum:
                            self.amon=float(dum.split()[-1])
                        if 'Minimum number of monomers' in dum:
                            self.npmin=float(dum.split()[-1]) 
                        if 'Maximum number of monomers' in dum:
                            self.npmax=float(dum.split()[-1]) 
                        if 'Minimum volume-equivalent radius' in dum:
                            self.avmin=float(dum.split()[-1])
                        if 'Maximum volume-equivalent radius' in dum:
                            self.avmax=float(dum.split()[-1])
                        if 'Power-law index' in dum:
                            self.pow=float(dum.split()[-1])
                        if 'Minimum characteristic radius' in dum:
                            self.acmin=float(dum.split()[-1])
                        if 'Maximum characteristic radius' in dum:
                            self.acmax=float(dum.split()[-1])
                        if 'Minimum porosity' in dum:
                            self.pormin=float(dum.split()[-1])
                        if 'Maximum porosity' in dum:
                            self.pormax=float(dum.split()[-1])
                        if 'Distribution averaged mass' in dum:
                            self.mass=float(dum.split()[-1])
                        if 'forward scattering chop angle' in dum:
                            self.chopang=float(dum.split()[-1])
                        if 'Scattering matrix definition: Bohren&Huffman' in dum:
                            print("Error! The scattering matrix definition is Bohren & Huffman's one.")
                            print("       The input file must be given in RADMC-3D's definition.     ")
                            exit()
                    else:
                        if 'material density' in dum:
                            self.rhomat=float(dum.split()[-1])
                        if 'Monomer radius' in dum:
                            self.amon=float(dum.split()[-1])
                        if 'Number of monomers' in dum:
                            self.np=float(dum.split()[-1]) 
                else:
                    if self.dist:
                        if 'material density' in dum:
                            self.rhomat=float(dum.split()[-1])
                        if 'Minimum volume-equivalent radius' in dum:
                            self.avmin=float(dum.split()[-1])
                        if 'Maximum volume-equivalent radius' in dum:
                            self.avmax=float(dum.split()[-1])
                        if 'Power-law index' in dum:
                            self.pow=float(dum.split()[-1])
                        if 'Distribution averaged mass' in dum:
                            self.mass=float(dum.split()[-1])
                        if 'forward scattering chop angle' in dum:
                            self.chopang=float(dum.split()[-1])
                        if 'Scattering matrix definition: Bohren&Huffman' in dum:
                            print("Error! The scattering matrix definition is Bohren & Huffman's one.")
                            print("       The input file must be given in RADMC-3D's definition.     ")
                            exit()
                    else:
                        if 'material density' in dum:
                            self.rhomat=float(dum.split()[-1])

                header = header + dum
                dum = f.readline()

            self.header=header
            self.iformat=int(dum)
            self.nlmd=int(f.readline())
            self.nang=int(f.readline())
            
            # preparing arrays
            self.lmd=np.zeros(self.nlmd)
            self.kabs=np.zeros(self.nlmd)
            self.ksca=np.zeros(self.nlmd)
            self.cabs=np.zeros(self.nlmd)
            self.csca=np.zeros(self.nlmd)
            self.asym=np.zeros(self.nlmd)
            self.pmax=np.zeros(self.nlmd)
            self.albedo=np.zeros(self.nlmd)

            self.scatang=np.zeros(self.nang)
            self.phase=np.zeros([self.nlmd,self.nang])
            self.smat11=np.zeros([self.nlmd,self.nang])
            self.smat12=np.zeros([self.nlmd,self.nang])
            self.smat22=np.zeros([self.nlmd,self.nang])
            self.smat33=np.zeros([self.nlmd,self.nang])
            self.smat34=np.zeros([self.nlmd,self.nang])
            self.smat44=np.zeros([self.nlmd,self.nang])

            dum=f.readline() # skip empty line
            for iwl in range(self.nlmd):
                dum=f.readline().split()
                self.lmd[iwl]=float(dum[0])
                self.kabs[iwl]=float(dum[1])
                self.ksca[iwl]=float(dum[2])
                self.asym[iwl]=float(dum[3])
                self.albedo[iwl]=self.ksca[iwl]/(self.kabs[iwl]+self.ksca[iwl])

            dum=f.readline() # skip empty line
            for iang in range(self.nang):
                dum=f.readline()
                self.scatang[iang]=float(dum)

            dum=f.readline() # skip empty line
            for iwl in range(self.nlmd):
                for iang in range(self.nang):
                    dum=f.readline().split()
                    self.smat11[iwl,iang]=float(dum[0])
                    self.smat12[iwl,iang]=float(dum[1])
                    self.smat22[iwl,iang]=float(dum[2])
                    self.smat33[iwl,iang]=float(dum[3])
                    self.smat34[iwl,iang]=float(dum[4])
                    self.smat44[iwl,iang]=float(dum[5])
                self.pmax[iwl]=max(-self.smat12[iwl,:]/self.smat11[iwl,:])

        # scattering phase function
        for iwl in range(self.nlmd):
            for iang in range(self.nang):
                self.phase[iwl,iang]=self.smat11[iwl,iang]/self.ksca[iwl]

        if read_default_file:
            # get radius, porosity of aggregates
            if self.aggop:
                if self.dist:
                    self.acmin,self.pormin = get_radius_and_porosity(partype,amon,str(int(self.npmin)))
                    self.acmax,self.pormax = get_radius_and_porosity(partype,amon,str(int(self.npmax)))
                else:
                    self.av  = self.amon * self.np**(1.0/3.0)
                    self.ac,self.por = get_radius_and_porosity(partype,amon,str(int(self.np)))

            # assign volume equivalent radius of single-sized grs
            if partype=='grs' and self.dist==False:
                self.av=grs_voleq(size)

            # calculate (distribution-averaged) mass [the last two arguments are not used when self.aggop=True]
            self.mass=calculate_dust_mass(self,3.5,sizemin='0_2000',sizemax=size)

        mic2cm=1.e-4
        cm2mic=1.e4
        # opacity (cm^2/g) ---> cross sectiosn (um^2)
        self.csca=self.ksca*self.mass*cm2mic*cm2mic
        self.cabs=self.kabs*self.mass*cm2mic*cm2mic

        # scattering matrix definition
        self.smatdef='radmc3d'
        if smatBH:
            self.smatdef='Bohren&Huffman'
            for iwl in range(self.nlmd):
                wavno=2.0*np.pi/(self.lmd[iwl]*mic2cm)
                self.smat11[iwl,:] = self.smat11[iwl,:] * self.mass * wavno * wavno
                self.smat12[iwl,:] = self.smat12[iwl,:] * self.mass * wavno * wavno
                self.smat22[iwl,:] = self.smat22[iwl,:] * self.mass * wavno * wavno
                self.smat33[iwl,:] = self.smat33[iwl,:] * self.mass * wavno * wavno
                self.smat34[iwl,:] = self.smat34[iwl,:] * self.mass * wavno * wavno
                self.smat44[iwl,:] = self.smat44[iwl,:] * self.mass * wavno * wavno


class distaverage:
    """
    A class to perform size distribution averaging 

    Parameters
    ----------
    partype : str
              Dust particle type:
              ``'FA11'``, ``'FA13'``, ``'FA15'``, ``'FA19'``, 
              ``'CAHP'``, ``'CAMP'``, ``'CALP'``, ``'grs'``
    sizemin : str
              Minimum dust particle in the size distribution
    sizemax : str
              Maximum dust particle in the size distribution
    comp    : str
              Dust composition. **Available input values**: ``'org'``, ``'amc'``
    amon    : str (optional)
              Monomer radius (necessary if you call aggregate files).
              **Available input values**:
              ``'100nm'``, (``'150nm'``), ``'200nm'``, (``'300nm'``), ``'400nm'``
              *Note*: 150nm and 300nm are only available for fractal aggregates.
    powind  : float (optional)
              Power-law index of size distribution
    chopang : float (optional)
              Chop angle for the forward scattering peak (degrees)
    smatBH : bool (optional)
             Switch the definition of the scattering matrix elements into Bohren & Huffman (default: smatBH=False).

    Attributes
    ----------
    model : str
            dust model name 
    path  : str
            A relative path to the file
    dist  : bool
            True when the size distribution is on (always True in this mode)
    aggop : bool
            True when the input particle type is aggregates
    nlam  : int
            Number of wavelength grids
    nang  : int
            Number of scattering angle grids
    lmd   : float[nlam]
            Wavelength (microns)
    scatang : float[nang]
            Scattering angles (degrees)
    kabs,ksca,asym : float[nlam]
            Absorption and scattering opacities (cm^2/g) and the asymmetry parameter.
    cabs,csca : float[nlam]
            Absorption and scattering cross sections (micron^2)
    albedo  : float[nlam]
            Single scattering albedo (=ksca/(kabs+ksca))
    pmax    : float[nlam]
            Maximum degree of linear polariation
    smat11,smat12,smat22,smat33,smat34,smat44: float[nlmd,nang]
            Scattering matrix elements (default: RADMC-3D definition)
    phase: float[nlmd,nang]
            Scattering phase function
    rhomat : float
            Material density (g/cc)
    chopang : float 
            The chop angle for the forward scattering peak (degrees)
    mass    : float
            Distribution-averaged dust mass (g)
    avmin, avmax  : float
            Volume-equivalent radii of the minimum and maximum dust particles in the size distribution
    pow    : float
            Power-law index of size distribution: n(a)da propto a^{-p}da
    amon   : float (*only when* ``partype!='grs'``)
            Monomer radius (microns)
            Number of monomers of the minimum aggregate in the size distribution
    npmin, npmax  : float (*only when* ``partype!='grs'``)
            Number of monomers of the minimum and maximum aggregates in the size distribution
    acmin, acmax  : float (*only when* ``partype!='grs'``)
            Characteristic radius of the minimum and maximum aggregates in the size distribution
    pormin,pormax : float (*only when* ``partype!='grs'``)
            Porosity of the minimum and maximum aggregates in the size distribution

    Methods
    -------
    write_dustkapscatmat:
        Output the optical properties in a format directly readable by RADMC-3D.
        
    """
    def __init__(self,partype,sizemin,sizemax,comp,amon=None,powind=3.5,chopang=0.0,smatBH=False):

        # check chop angle 
        if chopang < 0.0 or chopang>180.0:
            print('error: chop angle is outside the scattering angle range')
            print('input value = ',chopang)
            exit()
        self.chopang=chopang

        # check partype
        if partype not in ['grs','CALP','CAMP','CAHP','FA19','FA15','FA13','FA11']:
            print('error: incorrect particle type')
            print('input value = ',partype)
            print('available options are ',['grs','CALP','CAMP','CAHP','FA19','FA15','FA13','FA11'])
            exit()

        # if grs, reset monomer radius option
        if partype == 'grs':
            amon=None
            self.aggop=False
        else:
            self.aggop=True
 
        # get a list of particle size
        nl=get_sizelist(partype,amon=amon)
        
        # check consistency between monomer radius and number of monomers
        if sizemin not in nl or sizemax not in nl:
            print('Incorrect particle size')
            print('input particle type =',partype)
            if partype != 'grs':
                print('input monomer radius =',amon)
            if not nl:
                print('--> this monomer radius is not available')
            else:
                print('available size option is ',nl)
            exit()
        
        if self.aggop:
            imin=int(np.log2(int(sizemin)))
            imax=int(np.log2(int(sizemax)))
            ssmin=dustmodel(partype=partype,size=str(2**imin),amon=amon,comp=comp,dist=False)
            ssmax=dustmodel(partype=partype,size=str(2**imax),amon=amon,comp=comp,dist=False)
            self.amon=ssmax.amon
            self.rhomat=ssmax.rhomat
            self.npmin=int(ssmin.np)
            self.avmin=ssmin.av
            self.acmin=ssmin.ac
            self.pormin=ssmin.por
            self.npmax=int(ssmax.np)
            self.avmax=ssmax.av
            self.acmax=ssmax.ac
            self.pormax=ssmax.por
        else:
            grs_list=get_sizelist('grs')
            imin=grs_list.index(sizemin)
            imax=grs_list.index(sizemax)
            self.avmin = grs_voleq(grs_list[imin])
            self.avmax = grs_voleq(grs_list[imax])
            ssmin=dustmodel(partype='grs',size=grs_list[imin],comp=comp,dist=False)   
            ssmax=dustmodel(partype='grs',size=grs_list[imax],comp=comp,dist=False)   
            self.rhomat=ssmax.rhomat

        if imax<imin:
            print('ERROR: minimum size must be smaller than the maximum size')
            print('       stop.')
            exit()
    
        #
        self.partype=partype

        # copy the wavelength grid of the largest particle size
        self.nlmd=ssmax.nlmd   
        self.lmd=ssmax.lmd
        nlmd_max=7          # DO NOT CHANGE
        self.nang=ssmin.nang
        self.scatang=ssmin.scatang
        self.pow=powind

        # preparing arrays
        self.kabs=np.zeros(self.nlmd)
        self.ksca=np.zeros(self.nlmd)
        self.asym=np.zeros(self.nlmd)
        self.pmax=np.zeros(self.nlmd)
        self.albedo=np.zeros(self.nlmd)

        #self.scatang=np.zeros(self.nang)
        self.phase=np.zeros([self.nlmd,self.nang])
        self.smat11=np.zeros([self.nlmd,self.nang])
        self.smat12=np.zeros([self.nlmd,self.nang])
        self.smat22=np.zeros([self.nlmd,self.nang])
        self.smat33=np.zeros([self.nlmd,self.nang])
        self.smat34=np.zeros([self.nlmd,self.nang])
        self.smat44=np.zeros([self.nlmd,self.nang])

        #
        norm=np.zeros(self.nlmd)
        norm_g=np.zeros(self.nlmd)
        dang=self.scatang[1]-self.scatang[0]
        ichop=int(chopang/dang)  

        if ichop != 0:
            if self.aggop:
                self.model=partype+'_Nmin'+str(self.npmin)+'_Nmax'+str(self.npmax)+\
                        '_pow'+str(powind)+'_'+amon+'_'+comp+"_chop"+str(self.scatang[ichop])
            else:
                self.model=partype+'_rvmin'+grs_list[imin]+'um_rvmax'+grs_list[imax]+'um_pow'\
                        +str(powind)+'_'+comp+"_chop"+str(self.scatang[ichop])
        else:
            if self.aggop:
                self.model=partype+'_Nmin'+str(self.npmin)+'_Nmax'+str(self.npmax)+\
                        '_pow'+str(powind)+'_'+amon+'_'+comp
            else:
                self.model=partype+'_rvmin'+grs_list[imin]+'um_rvmax'+grs_list[imax]+'um_pow'+str(powind)+'_'+comp


        # distribution averaging
        for i in range (imin,imax+1):
            if self.aggop:
                ss=dustmodel(partype=partype,size=str(2**i),amon=amon,comp=comp,dist=False)    
            else:
                ss=dustmodel(partype='grs',size=grs_list[i],comp=comp,dist=False)            
            
            for iwl in range(self.nlmd):    
                lam_index=iwl+ss.nlmd-self.nlmd  
                #print(ss.nlmd,iwl,ss.lmd[lam_index])

                weight=ss.av**(4.0-powind)
                norm[iwl]=norm[iwl]+weight 
                norm_g[iwl]=norm_g[iwl]+weight * ss.ksca[lam_index]
                self.kabs[iwl]=self.kabs[iwl] + weight * ss.kabs[lam_index]
                self.ksca[iwl]=self.ksca[iwl] + weight * ss.ksca[lam_index]
                self.asym[iwl]=self.asym[iwl] + weight * ss.ksca[lam_index] * ss.asym[lam_index]
                
                increment=int((ss.nang-1)/(self.nang-1))
                for iang in range(self.nang):
                    ang_ind=iang*increment
                    #print(ss.nang,iang,ss.scatang[ang_ind])

                    self.smat11[iwl,iang] = self.smat11[iwl,iang] + weight * ss.smat11[lam_index,ang_ind]
                    self.smat12[iwl,iang] = self.smat12[iwl,iang] + weight * ss.smat12[lam_index,ang_ind]
                    self.smat22[iwl,iang] = self.smat22[iwl,iang] + weight * ss.smat22[lam_index,ang_ind]
                    self.smat33[iwl,iang] = self.smat33[iwl,iang] + weight * ss.smat33[lam_index,ang_ind]
                    self.smat34[iwl,iang] = self.smat34[iwl,iang] + weight * ss.smat34[lam_index,ang_ind]
                    self.smat44[iwl,iang] = self.smat44[iwl,iang] + weight * ss.smat44[lam_index,ang_ind]
                
        for iwl in range(self.nlmd):        
            self.kabs[iwl]=self.kabs[iwl]/norm[iwl]
            self.ksca[iwl]=self.ksca[iwl]/norm[iwl]
            self.asym[iwl]=self.asym[iwl]/norm_g[iwl]
            self.smat11[iwl,:]=self.smat11[iwl,:] / norm[iwl]
            self.smat12[iwl,:]=self.smat12[iwl,:] / norm[iwl]
            self.smat22[iwl,:]=self.smat22[iwl,:] / norm[iwl]
            self.smat33[iwl,:]=self.smat33[iwl,:] / norm[iwl]
            self.smat34[iwl,:]=self.smat34[iwl,:] / norm[iwl]
            self.smat44[iwl,:]=self.smat44[iwl,:] / norm[iwl]
            self.pmax[iwl]=max(-self.smat12[iwl,:]/self.smat11[iwl,:])
        
            if ichop != 0:
                for iang in range(0,ichop+1):
                    # store polarization states before chopping
                    R12=self.smat12[iwl,iang]/self.smat11[iwl,iang]
                    R22=self.smat22[iwl,iang]/self.smat11[iwl,iang]
                    R33=self.smat33[iwl,iang]/self.smat11[iwl,iang]
                    R34=self.smat34[iwl,iang]/self.smat11[iwl,iang]
                    R44=self.smat44[iwl,iang]/self.smat11[iwl,iang]
                    # chop the forward scattering peak
                    self.smat11[iwl,iang] = self.smat11[iwl,ichop]
                    # re-compute scattering matrix elements with the flattened Z11_ave
                    # so as to preserve the original polarization states
                    self.smat12[iwl,iang] = R12 * self.smat11[iwl,iang]
                    self.smat22[iwl,iang] = R22 * self.smat11[iwl,iang]
                    self.smat33[iwl,iang] = R33 * self.smat11[iwl,iang]
                    self.smat34[iwl,iang] = R34 * self.smat11[iwl,iang]
                    self.smat44[iwl,iang] = R44 * self.smat11[iwl,iang]
                    
            # Recompute scattering opacity and asymmetry parameter
            # mu-space integration of Z11 (as done in RADMC3D)
            tot1=0.0
            tot2=0.0
            d2r=np.pi/180.0    
            for iang in range(1,self.nang):
                mu1=np.cos(self.scatang[iang-1]*d2r)
                mu2=np.cos(self.scatang[iang]*d2r)    
                dummy=np.pi*(mu1-mu2) #  (Note) = 0.5 * 2*pi * deltamu = pi*deltamu
                tot1 = tot1 + dummy * (self.smat11[iwl,iang-1] + self.smat11[iwl,iang])
                tot2 = tot2 + dummy * (self.smat11[iwl,iang-1] + self.smat11[iwl,iang]) * 0.5 * (mu1+mu2)

            #
            if ichop == 0:
                err_ksca=np.abs(self.ksca[iwl]-tot1)/tot1
                err_asym=np.abs(self.asym[iwl]-tot2/tot1)/(tot2/tot1)
                if err_ksca > 0.001:
                    print('Mismatch between ksca and the integrated value of Z11 exceeds 0.1%.')
                    print('ksca       = ',self.ksca[iwl])
                    print('ksca (z11) = ',tot1)
                    print('difference in g = ',err_ksca)
                    print('something went wrong in the averaging process...')

                if err_asym > 0.001:
                    print('Mismatch between <g> and the integrated value of Z11*mu exceeds 0.1%.')
                    print('<g>       = ',self.asym[iwl])
                    print('<g> (z11) = ',tot2/tot1)
                    print('difference in g = ',err_asym)
                    print('something went wrong in the averaging process...')

            # update ksca and asymmetry parameter 
            self.ksca[iwl] = tot1
            self.asym[iwl] = tot2/tot1

            self.albedo[iwl] = self.ksca[iwl]/(self.ksca[iwl]+self.kabs[iwl])

        # scattering phase function
        for iwl in range(self.nlmd):
            for iang in range(self.nang):
                self.phase[iwl,iang]=self.smat11[iwl,iang]/self.ksca[iwl]

        # calculate the distribution-averaged mass 
        self.dist=True
        self.mass=calculate_dust_mass(self,powind,sizemin=sizemin,sizemax=sizemax)

        cm2mic=1.e4
        mic2cm=1.e-4

        # opacity (cm^2/g) ---> cross sectiosn (um^2)
        self.csca=self.ksca*self.mass*cm2mic*cm2mic
        self.cabs=self.kabs*self.mass*cm2mic*cm2mic

        # scattering matrix definition
        self.smatdef='radmc3d'
        if smatBH:
            self.smatdef='Bohren&Huffman'
            for iwl in range(self.nlmd):
                wavno=2.0*np.pi/(self.lmd[iwl]*mic2cm)
                self.smat11[iwl,:] = self.smat11[iwl,:] * self.mass * wavno * wavno
                self.smat12[iwl,:] = self.smat12[iwl,:] * self.mass * wavno * wavno
                self.smat22[iwl,:] = self.smat22[iwl,:] * self.mass * wavno * wavno
                self.smat33[iwl,:] = self.smat33[iwl,:] * self.mass * wavno * wavno
                self.smat34[iwl,:] = self.smat34[iwl,:] * self.mass * wavno * wavno
                self.smat44[iwl,:] = self.smat44[iwl,:] * self.mass * wavno * wavno

    def write_dustkapscatmat(self,fn=None):
        """
        Output dustkapscatmat_XXX.inp

        Parameters
        ----------
        fn : str (optional)
             Filename for the ouput file
        """
      
        if fn==None:
            fn=self.model

        if self.smatdef=='Bohren&Huffman':
            print("Error! The scattering matrix definition is not RADMC-3D's definition.")
            print("       Set smatBH=False when creating an instance.")
            exit()

        filename='dustkapscatmat_'+fn+'.inp'
        print('writing ...',filename)

        with open(filename,'w') as fout:
            dustspec_header(self,specoutput=fout)
            fout.write("%12d\n"%(1))
            fout.write("%12d\n"%(self.nlmd))
            fout.write("%12d\n"%(self.nang))
            fout.write("\n")
            for iwl in range(self.nlmd):
                fout.write("%18.8e %18.8e %18.8e %18.8e\n"\
                        %(self.lmd[iwl],self.kabs[iwl],self.ksca[iwl],self.asym[iwl]))
            fout.write("\n")
            for iang in range(self.nang):
                fout.write("%18.8e\n"%(self.scatang[iang]))
                   
            fout.write("\n")

            for iwl in range(self.nlmd):
                for iang in range(self.nang):
                    fout.write("%18.8e %18.8e %18.8e %18.8e %18.8e %18.8e\n"\
                                          %(self.smat11[iwl,iang],self.smat12[iwl,iang],\
                                           self.smat22[iwl,iang],self.smat33[iwl,iang],\
                                           self.smat34[iwl,iang],self.smat44[iwl,iang]))

def dustspec_header(self,specoutput=None):
    """
    Header information about dust properties

    Parameters
    ----------
    specoutput  :  str (optional)
                   To which the results are redirected

    """
    print('#==========================================================', file=specoutput)
    print('# Generated by AggScatVIR database               ',   file=specoutput)
    print('# dust model = %-s'%self.model,                       file=specoutput)
    print('# file format    : RADMC-3D v2.0 dustkapscatmat.inp', file=specoutput)
    print('# normalizations : RADMC-3D conventions',file=specoutput)
    if self.aggop:
        print('# Monomer radius (um)                   = %-8.5f'%self.amon,   file=specoutput)
        print('# material density (g/cc)               = %-7.4f'%self.rhomat, file=specoutput)
        print('# Minimum number of monomers            = %-5i'%self.npmin,    file=specoutput)
        print('# Minimum volume-equivalent radius (um) = %-8.5e'%self.avmin,  file=specoutput)
        print('# Minimum characteristic radius    (um) = %-8.5e'%self.acmin,  file=specoutput)
        print('# Minimum porosity (%%)                  = %-7.2f'%self.pormin,file=specoutput)
        print('# Maximum number of monomers            = %-5i'%self.npmax,    file=specoutput)
        print('# Maximum volume-equivalent radius (um) = %-8.5e'%self.avmax,  file=specoutput)
        print('# Maximum characteristic radius    (um) = %-8.5e'%self.acmax,  file=specoutput)
        print('# Maximum porosity (%%)                  = %-7.2f'%self.pormax,file=specoutput)
    else:
        print('# material density (g/cc)               = %-7.4f'%self.rhomat, file=specoutput)
        print('# Minimum volume-equivalent radius (um) = %-8.5e'%self.avmin,  file=specoutput)
        print('# Maximum volume-equivalent radius (um) = %-8.5e'%self.avmax,  file=specoutput)
    print('# Distribution averaged mass (g)        = %-13.8e'%self.mass,      file=specoutput)
    print('# Power-law index of size dist.         = %-8.5e'%self.pow,        file=specoutput)
    print('# forward scattering chop angle (deg)   = %-8.5e'%self.chopang,    file=specoutput)
    print('#=========================================================',       file=specoutput)


def dustspec(self,specoutput=None):
    """
    Print info about dust properties

    Parameters
    ----------
    specoutput  :  str (optional)
                   To which the results are redirected 
    """
    if self.aggop:
        if self.dist:
            print('=============== Dust Parameters ================',    file=specoutput)
            print(' Model name = %-s'%self.model,                        file=specoutput)
            print(' Monomer radius           (um) = %-8.5f'%self.amon,   file=specoutput)
            print(' Material density       (g/cc) = %-7.4f'%self.rhomat, file=specoutput)
            print(' -----Minimum aggregate in the distribution-----',    file=specoutput)
            print(' Number of monomers            = %-5i'%self.npmin,    file=specoutput)
            print(' Volume-eq radius         (um) = %-8.5e'%self.avmin,  file=specoutput)
            print(' Characteristic radius    (um) = %-8.5e'%self.acmin,  file=specoutput)
            print(' Porosity                  (%%) = %-7.2f'%self.pormin,file=specoutput)
            print(' -----Maximum aggregate in the distribution-----',    file=specoutput)
            print(' Number of monomers            = %-5i'%self.npmax,    file=specoutput)
            print(' Volume-eq radius         (um) = %-8.5e'%self.avmax,  file=specoutput)
            print(' Characteristic radius    (um) = %-8.5e'%self.acmax,  file=specoutput)
            print(' Porosity                  (%%) = %-7.2f'%self.pormax,file=specoutput)
            print(' -----------------------------------------------',    file=specoutput)
            print(' Power-law index of size dist. = %-8.5e'%self.pow,    file=specoutput)
            print(' chop angle (deg)              = %-8.5e'%self.chopang,file=specoutput)
            print('================================================',    file=specoutput)
        else:
            print('=============== Dust Parameters ================',   file=specoutput)
            print(' Model name = %-s'%self.model,file=specoutput)
            print(' Monomer radius           (um) = %-8.5f'%self.amon,   file=specoutput)
            print(' Material density       (g/cc) = %-7.4f'%self.rhomat, file=specoutput)
            print(' Number of monomers            = %-5i'%self.np,       file=specoutput)
            print(' Volume equivalent radius (um) = %-8.5e'%self.av,     file=specoutput)
            print(' Characteristic radius    (um) = %-7.4f'%self.ac,     file=specoutput)
            print(' Porosity                  (%%) = %-7.2f'%self.por,   file=specoutput)
            print(' chop angle (deg)              = %-8.5e'%self.chopang,file=specoutput)
            print('================================================',    file=specoutput)
    else:
        if self.dist:
            print('=============== Dust Parameters ===============',    file=specoutput)
            print(' Model name = %-s'%self.model,file=specoutput)
            print(' Material density       (g/cc)  = %-7.4f'%self.rhomat,file=specoutput)
            print(' Minimium volume-eq radius (um) = %-8.5e'%self.avmin, file=specoutput)
            print(' Maximum  volume-eq radius (um) = %-8.5e'%self.avmax, file=specoutput)
            print(' Power-law index of size dist.  = %-8.5e'%self.pow,   file=specoutput)
            print(' chop angle (deg)               = %-8.5e'%self.chopang,file=specoutput)
            print('================================================',    file=specoutput)
        else:
            print('=============== Dust Parameters ===============',    file=specoutput)
            print(' Model name = %-s'%self.model,file=specoutput)
            print(' Material density       (g/cc) = %-7.4f'%self.rhomat, file=specoutput)
            print(' Volume equivalent radius (um) = %-8.5e'%self.av,     file=specoutput)
            print(' chop angle (deg)              = %-8.5e'%self.chopang,file=specoutput)
            print('================================================',    file=specoutput)



def showmodel(self,opacity=True,savefig=False,fn=None):
    """
    Show summary plots of the optical property

    Parameters
    ----------
    opacity  :  bool (optional)
                A switch to decide whether to plot the opacity or the cross-section
    savefig  :  bool (optional)
                If True, then the plots is saved.
    fn       :  str (optional)
                Filename for the ouput file
    """

    #fig,axes = plt.subplots(2,2,figsize=(15,12),gridspec_kw={'hspace': 0.0, 'wspace': 0.2, 'width_ratios': [1,1]})
    fig,axes = plt.subplots(2,2,figsize=(15,12),gridspec_kw={'hspace':0.4})

    if opacity:
        axes[0,0].set_title('Opacity',fontsize=20)
        plots.set_lmd_vs_opc(axes[0,0])
        axes[0,0].plot(self.lmd,self.kabs,linewidth=3,c='black',linestyle='-',label='$\kappa_\mathrm{abs}$')
        axes[0,0].plot(self.lmd,self.ksca,linewidth=3,c='black',linestyle='--',label='$\kappa_\mathrm{sca}$')
    else:
        axes[0,0].set_title('cross section ($\mu\mathrm{m}^2$)',fontsize=20)
        plots.set_lmd_vs_cross(axes[0,0])
        axes[0,0].plot(self.lmd,self.cabs,linewidth=3,c='black',linestyle='-',label='$C_\mathrm{abs}$')
        axes[0,0].plot(self.lmd,self.csca,linewidth=3,c='black',linestyle='--',label='$C_\mathrm{sca}$')
    
    axes[1,0].set_title('Albedo, Max pol, asymmetry parameter',fontsize=20)
    plots.set_lmd_vs_albedo(axes[1,0])
    axes[1,0].plot(self.lmd,self.pmax,linewidth=3,c='black',linestyle='--',label='$P_\mathrm{max}$')
    axes[1,0].plot(self.lmd,self.asym,linewidth=3,c='black',linestyle=':',label='$g$')
    axes[1,0].plot(self.lmd,self.ksca/(self.kabs+self.ksca),linewidth=3,c='black',linestyle='-',label='$\omega$')

    plots.set_ang_vs_phase(axes[0,1])
    plots.set_ang_vs_pol(axes[1,1])

    axes[0,1].set_title('Phase function',fontsize=20)
    axes[1,1].set_title('Degree of linear polarization',fontsize=20)
    for iwl in range(self.nlmd):
        axes[0,1].plot(self.scatang[:],self.smat11[iwl,:]/self.ksca[iwl],\
                    label='$\lambda=$'+str(self.lmd[iwl])+' $\mu\mathrm{m}$')
        axes[1,1].plot(self.scatang[:],-self.smat12[iwl,:]/self.smat11[iwl,:],\
                    label='$\lambda=$'+str(self.lmd[iwl])+' $\mu\mathrm{m}$')

    axes[0,0].legend(fontsize=16)
    axes[1,0].legend(fontsize=16)
    axes[0,1].legend(fontsize=16)
    #axes[1,1].legend(fontsize=16)

    # save figure
    if savefig:
        if fn==None:
            fn = self.model+'.pdf'
        print('... saveing the plot as',fn)
        plt.savefig(str(fn),bbox_inches='tight', pad_inches=0.05)


def output_all_gallery_plot(partype,amon=None,dist=True):
    """
    Output plots for Appendix B (gallery of the optical properties)

    Parameters
    ----------
    partype : str
              Dust particle type:
              ``'FA11'``, ``'FA13'``, ``'FA15'``, ``'FA19'``,
              ``'CAHP'``, ``'CAMP'``, ``'CALP'``, ``'grs'``
    amon    : str (optional)
              Monomer radius (necessary if you call aggregate files).
              **Available input values**:
              ``'100nm'``, (``'150nm'``), ``'200nm'``, (``'300nm'``), ``'400nm'``
              *Note*: 150nm and 300nm are only available for fractal aggregates.
    dist : bool (optional)
           With size distribution (default: dist=True).

    """

    fig,axes = plt.subplots(2,4,figsize=(20,10))

    complist=['org','amc']

    # get aggregate size
    if partype=='grs':
        if dist:
            filename='./figs/'+partype+'_distave.png'
        else:
            filename='./figs/'+partype+'_single.png'

        amon=None
        nlist=get_sizelist(partype)
    else:
        if dist:
            filename='./figs/'+partype+'_'+amon+'_distave.png'
        else:
            filename='./figs/'+partype+'_'+amon+'_single.png'

        nlist=get_sizelist(partype,amon) 

    print('generating plots of ',filename)
    
    axes[0,0].set_title('Opacity (cm$^2$/g)',fontsize=22)
    axes[0,1].set_title('$\omega$, $P_\mathrm{max}$, Albedo',fontsize=22)
    axes[0,2].set_title('Phase function ($\lambda=1.04~\mu$m)',fontsize=22)
    axes[0,3].set_title('Degree of polarization ($\lambda=1.04~\mu$m)',fontsize=22)

    for j,jcomp in enumerate(complist):
        
        plots.set_lmd_vs_opc(axes[j,0])
        plots.set_lmd_vs_albedo(axes[j,1])
        plots.set_ang_vs_phase(axes[j,2])
        plots.set_ang_vs_pol(axes[j,3])

        axes[j,3].set_ylim(-0.6,1.05)
        axes[j,0].text(0.65,280,jcomp,fontsize=40)

        for i,isize in enumerate(nlist):
            #print(isize,j,jcomp)
            apl=dustmodel(partype=partype,amon=amon,size=isize,comp=jcomp,dist=dist)

            # opacity
            axes[j,0].plot(apl.lmd,apl.kabs,c='C'+str(i),linestyle='--')
            axes[j,0].plot(apl.lmd,apl.ksca,c='C'+str(i),linestyle='-')

            # asym, pmax, and albedo
            axes[j,1].plot(apl.lmd,apl.pmax,c='C'+str(i),linestyle='--')
            axes[j,1].plot(apl.lmd,apl.asym,c='C'+str(i),linestyle=':')
            axes[j,1].plot(apl.lmd,apl.albedo,c='C'+str(i),linestyle='-')

            # wavelength index (at lambda = 1.04 um)
            iww = 2 - ( 7 - apl.nlmd)
            #print('wavelength for smat: ',apl.lmd[iww])
            
            # phase function
            axes[j,2].plot(apl.scatang,\
                    apl.phase[iww,:],c='C'+str(i),linestyle='-')

            # degree of linear polarization
            axes[j,3].plot(apl.scatang,-apl.\
                    smat12[iww,:]/apl.smat11[iww,:],c='C'+str(i),\
                    linestyle='-',label=apl.model[0:-4])
    
    # dummy plot for legend
    axes[0,0].plot(-9999,-9999,linestyle='-',c='black',label='$\kappa_\mathrm{sca}$')
    axes[0,0].plot(-9999,-9999,linestyle='--',c='black',label='$\kappa_\mathrm{abs}$')

    axes[0,1].plot(-9999,-9999,linestyle='--',c='black',label='$P_\mathrm{max}$')
    axes[0,1].plot(-9999,-9999,linestyle=':',c='black',label='$g$')
    axes[0,1].plot(-9999,-9999,linestyle='-',c='black',label='$\omega$')
    
    axes[0,0].legend(fontsize=22)
    axes[0,1].legend(fontsize=22)
   
    # cut margin
    plt.tight_layout() 

    # shrink the subplots to make a room for legend
    for i in range(4):
        box = axes[0,i].get_position()
        yoff=box.height * 0.125
        axes[0,i].set_position([box.x0, box.y0 + box.height * 0.125, box.width, box.height*0.875])
        box = axes[1,i].get_position()
        axes[1,i].set_position([box.x0, box.y0 + box.height * 0.125 + yoff, box.width, box.height*0.875])
    
    # make legend
    bb = (fig.subplotpars.left, fig.subplotpars.bottom-0.065, 
      fig.subplotpars.right-fig.subplotpars.left,.1)
    axes[0,3].legend(bbox_to_anchor=bb, mode="expand", loc="lower left",
               ncol=5, borderaxespad=0., bbox_transform=fig.transFigure,fontsize=20)

    plt.savefig(filename,transparent=False,facecolor='white')

    plt.close()


def write_data(self,fn=None,output='all',wlist=None):
    """
    Write optical properties of dust particles in various formats

    Parameters
    ----------
    output  :  str (optional)
               Determines what kind of optical properties will be outputted ('all', 'integrated', 'smat').
    wlist   :  list of float (optional)
               Determines which wavelength data will be outputted.
    fn       :  str (optional)
               Filename for the ouput file
    """

    if fn==None:
        fn=self.model

    if output=='all':
        filename='dustkapscatmat_'+fn+'.out'
        print('writing ...',filename)
        with open(filename,'w') as fout:
            dustspec_header(self,specoutput=fout)
            fout.write("# Scattering matrix definition: %s\n"%(self.smatdef))
            fout.write("%12d\n"%(self.nlmd))
            fout.write("%12d\n"%(self.nang))
            fout.write("\n")
            fout.write("#%17s %18s %18s %18s %18s %18s\n"\
                     %("wavel (um)","kabs (cm^2/g)","ksca (cm^2/g)",\
                       "Cabs (um^2)","Csca (um^2)","asymmetry param"))
            for iwl in range(self.nlmd):
                fout.write("%18.8e %18.8e %18.8e %18.8e %18.8e %18.8e\n"\
                        %(self.lmd[iwl],self.kabs[iwl],self.ksca[iwl],\
                        self.cabs[iwl],self.csca[iwl],self.asym[iwl]))

            fout.write("\n")
            for iang in range(self.nang):
                fout.write("%18.8e\n"%(self.scatang[iang]))
                   
            fout.write("\n")
            
            if self.smatdef=='radmc3d':
                fout.write("#%17s %18s %18s %18s %18s %18s\n"\
                         %("Z11","Z12","Z22","Z33","Z34","Z44"))
            elif self.smatdef=='Bohren&Huffman':
                fout.write("#%17s %18s %18s %18s %18s %18s\n"\
                         %("S11","S12","S22","S33","S34","S44"))
            else:
                print('ERROR: unknown definition of the scattering matrix.')
                print('       something went wrong. STOP')
                exit()

            for iwl in range(self.nlmd):
                for iang in range(self.nang):
                    fout.write("%18.8e %18.8e %18.8e %18.8e %18.8e %18.8e\n"\
                              %(self.smat11[iwl,iang],self.smat12[iwl,iang],\
                                self.smat22[iwl,iang],self.smat33[iwl,iang],\
                                self.smat34[iwl,iang],self.smat44[iwl,iang]))

    elif output=='integrated':
        filename='integrated_'+fn+'.out'
        print('writing ...',filename)
        with open(filename,'w') as fout:
            dustspec_header(self,specoutput=fout)
            fout.write("#%17s %18s %18s %18s %18s %18s\n"\
                    %("wavel (um)","kabs (cm^2/g)","ksca (cm^2/g)",\
                      "Cabs (um^2)","Csca (um^2)","asymmetry param"))
            for iwl in range(self.nlmd):
                fout.write("%18.8e %18.8e %18.8e %18.8e %18.8e %18.8e\n"\
                        %(self.lmd[iwl],self.kabs[iwl],self.ksca[iwl],\
                        self.cabs[iwl],self.csca[iwl],self.asym[iwl]))

    elif output=='smat':
        if wlist==None:
            if self.nlmd==7:
                wlist=[0.554,0.735,1.04,1.25,1.63,2.18,3.78]
            elif self.nlmd==5:
                wlist=[1.04,1.25,1.63,2.18,3.78]

        for iwlname in wlist:
            try:
                iwl=self.lmd.tolist().index(iwlname)
            except ValueError:
                print('error : available wavelength :',self.lmd.tolist())
                print('        STOP')

            filename='scatmat_'+fn+'_lmd'+str(iwlname)+'um.out'
            print('writing ...',filename)
            with open(filename,'w') as fout:
                dustspec_header(self,specoutput=fout)
                fout.write("# Scattering matrix definition: %s\n"%(self.smatdef))
                fout.write("# wavelength = %6.3f um\n"%(self.lmd[iwl]))
                fout.write("# absorption opacity (cm^2/g) and cross section (um^2) = %18.8e %18.8e\n"\
                        %(self.kabs[iwl],self.cabs[iwl]))
                fout.write("# scattering opacity (cm^2/g) and cross section (um^2) = %18.8e %18.8e\n"\
                        %(self.ksca[iwl],self.csca[iwl]))
                fout.write("# asymmetry parameter = %18.8e\n"%(self.asym[iwl]))
                if self.smatdef=='radmc3d':
                    fout.write("#%17s %18s %18s %18s %18s %18s %18s %18s\n"\
                            %("angle (deg)","phase func","Z11","Z12","Z22","Z33","Z34","Z44"))
                elif self.smatdef=='Bohren&Huffman':
                    fout.write("#%17s %18s %18s %18s %18s %18s %18s %18s\n"\
                            %("angle (deg)","phase func","S11","S12","S22","S33","S34","S44"))
                for iang in range(self.nang):
                    fout.write("%18.3f %18.8e %18.8e %18.8e %18.8e %18.8e %18.8e %18.8e \n"\
                                          %(self.scatang[iang],self.phase[iwl,iang],\
                                          self.smat11[iwl,iang],self.smat12[iwl,iang],\
                                          self.smat22[iwl,iang],self.smat33[iwl,iang],\
                                          self.smat34[iwl,iang],self.smat44[iwl,iang]))

    else:
        print('ERROR: output data option is incorrent. STOP')
        exit()

if __name__ == '__main__':

    a=dustmodel(partype='CAHP',size='4096',amon='100nm',comp='amc')
    a.path
    dustapec(a)
